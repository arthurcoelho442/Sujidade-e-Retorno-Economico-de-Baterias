# -*- coding: utf-8 -*-
"""atual copy 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EJuCke8QI2up4CdSIcHJZdsXrlnBNvhr

# **Inicialização**
"""

# pip install -r requirements.txt

#@title **Bibliotecas**

from operator import itemgetter
from datetime import datetime
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import math
import random
import os
from random import shuffle
from pymoo.problems.functional import FunctionalProblem
from pymoo.algorithms.moo.nsga3 import NSGA3
from pymoo.optimize import minimize
from pymoo.visualization.scatter import Scatter
from pymoo.util.ref_dirs import get_reference_directions
from pvlib.soiling import kimber

#@title **Dados de consumo database Bear_education_Danna e Bear_education_Darrell**

dir = "./Genome_Separate_Buildings/"

# Listar todos os arquivos na pasta
all_files = os.listdir(dir)
csv_files = [f for f in all_files if f.endswith('.csv')]

# Embaralhar a lista de arquivos CSV
shuffle(csv_files)

# Função para extrair o nome do usuário do nome do arquivo
def extract_user_name(file_name):
    # Extrai o nome entre underscores (_nome_)
    parts = file_name.split('_')
    if len(parts) >= 2:  # Verifica se há pelo menos dois underscores
        return parts[-1].split('.')[0]  # Pega a última parte antes do .csv
    return None

# Número máximo de usuários que você quer processar
max_users = 100  # Altere este valor para o número desejado

defalt_users = [
    {
        "Bear_education_": ["Darrell", "Gavin", "Iris", "Clint"]},
    {
        "Wolf_education_": ['Miguel', 'Vivian']},
    {
        "Wolf_office_": ['Emanuel']},
    {
        "Swan_unknown_": ['Bette', 'Isaiah', 'Reyna']}]

# Lista para armazenar os arquivos e os nomes dos usuários
arquivos = []
users = []

for files in defalt_users:
    for chave, users_names in files.items():
        arquivos += [(dir + chave+user+'.csv',user) for user in users_names]
        users += users_names

# Processar os arquivos
for file_name in csv_files:
    if len(users) >= max_users:
        break
    user_name = extract_user_name(file_name)
    if user_name:
        if user_name not in users:
            users.append(user_name)
            arquivos.append((dir + file_name, user_name))

# Dicionário para armazenar os dados dos consumidores
consumidor = {}

# Processar cada arquivo
for arquivo, cosumidor_name in arquivos:
    c = pd.read_csv(arquivo, delimiter=",").iloc[:, 1:]
    c = c.set_axis(list(c.iloc[:, 0]), axis=0).iloc[:, 1:]

    # Converter o índice para o tipo de dados 'datetime'
    c.index = pd.to_datetime(c.index)

    # Criar uma série com intervalo de horas para o período desejado
    periodo_completo = pd.date_range(start="2016-01-01 00:00:00", end="2017-12-31 23:00:00", freq='h')

    # Reamostrar o DataFrame para o novo período completo e aplicar a interpolação linear
    consumidor[cosumidor_name] = c.reindex(periodo_completo).interpolate(method='linear')

    print((cosumidor_name, consumidor[cosumidor_name].mean().iloc[0]), end=" ")

consumidor[users[0]]

def label_figure(users, title, ylabel, xlabel, fontsize, rotation):
    # plt.title(title,  fontsize = fontsize)
    plt.ylabel(ylabel,  fontsize = fontsize)
    plt.xlabel(xlabel,  fontsize = fontsize)
    plt.xticks(fontsize=fontsize-3, rotation=rotation)
    plt.yticks(fontsize=fontsize-3)

    if len(users) > 0:
        plt.legend(users, loc='lower center', bbox_to_anchor=(0.5, 1.0), ncol=5, fontsize=fontsize-3)

    plt.tight_layout()

#@title **Comsumo de 2016 à 2017**
font = 18
plt.figure(figsize=(11,5))
for user in users[:10]:
    plt.plot(consumidor[user].resample('ME').mean())

plt.ylabel('Consumo(kWh)',  fontsize = font)
plt.xlabel('Mês',  fontsize = font)
plt.xticks(fontsize=font-3)
plt.yticks(fontsize=font-3)

if len(users) > 0:
    plt.legend(users, loc='lower center', bbox_to_anchor=(0.5, 1.0), ncol=5, fontsize=font-4)

plt.tight_layout()

os.makedirs("./figuras/consumo", exist_ok=True)
plt.savefig(f"./figuras/consumo/{max_users}-consumo.eps", format='eps')
plt.show()

#@title **Acesso aos Arquivos Meterologicos**
# https://mapas.inmet.gov.br/

Met = {}
anos = ['2016', '2017']
for ano in anos:
    arquivo = f"./smart-grid/dados/{ano}/INMET_SE_ES_A612_VITORIA_01-01-{ano}_A_31-12-{ano}.csv"
    Met[ano] = pd.read_csv(os.path.abspath(arquivo), delimiter=";")

DadosMet = pd.concat([Met[ano] for ano in anos])

colunas_selecionadas = ["Data","Hora (UTC)","Temp. Ins. (C)","Vel. Vento (m/s)","Radiacao (KJ/m²)", "Chuva (mm)"]
DadosMet = DadosMet[colunas_selecionadas]
DadosMet.columns=['Data','Hora','temperatura', 'vento', 'radiacao', 'chuva']

# Acerto Hora
try:
    DadosMet['Hora'] /= 100
    DadosMet['Hora'] = DadosMet['Hora'].astype(str).str.replace(".0", ":00")
    DadosMet['Data'] = pd.to_datetime(DadosMet['Data'] + ' ' + DadosMet['Hora'], format='%d/%m/%Y %H:%M')
except:
    DadosMet['Data'] = pd.to_datetime(DadosMet['Data'] + ' ' + DadosMet['Hora'])
# DadosMet = DadosMet.set_axis(list(DadosMet['Data']), axis=0)

# Definir a coluna 'Data' como índice
DadosMet = DadosMet.set_index('Data')

# Converter vírgulas para pontos e transformar em numérico
DadosMet['radiacao'] = pd.to_numeric(DadosMet['radiacao'].str.replace(",", "."), errors='coerce')
DadosMet['temperatura'] = pd.to_numeric(DadosMet['temperatura'].str.replace(",", "."), errors='coerce')
DadosMet['vento'] = pd.to_numeric(DadosMet['vento'].str.replace(",", "."), errors='coerce')
DadosMet['chuva'] = pd.to_numeric(DadosMet['chuva'].str.replace(",", "."), errors='coerce')

DadosMet['radiacao'] = DadosMet['radiacao'].fillna(0.0)

# Calcular irradiância solar (converter kJ/m² para W/m²)
DadosMet['irradiancia'] = round(DadosMet['radiacao'] * 0.2777777778, 1)

# Remover colunas desnecessárias
DadosMet = DadosMet.drop(columns=['Hora', 'radiacao'])

# Interpolar valores faltantes
DadosMet = DadosMet.interpolate(method='time').bfill()

# Garantir que o índice seja datetime
DadosMet.index = pd.to_datetime(DadosMet.index)

DadosMet

#@title **Gráfico irradiancia dia 1 do primeiro ano**
plt.figure(figsize=(10,4))

plt.grid(True)
plt.title(f'Irradiancia dia {anos[0]}-01-01',  fontsize = 10)
plt.ylabel('Irradiancia (wh/m²)',  fontsize = 10)
plt.xlabel('Horas',  fontsize = 10)

plt.plot(DadosMet['irradiancia'][:24], color='orange')
plt.show()

#@title **Gráfico Vento dia 1 do primeiro ano**
plt.figure(figsize=(10,4))

plt.grid(True)
plt.title(f'Velocidade do vento dia {anos[0]}-01-01',  fontsize = 10)
plt.ylabel('Velocidade (m/s)',  fontsize = 10)
plt.xlabel('Horas',  fontsize = 10)

plt.plot(DadosMet['vento'][:24], color='grey')
plt.show()

plt.figure(figsize=(10,4))

plt.grid(True)
plt.title(f'Temperatura dia {anos[0]}-01-01',  fontsize = 10)
plt.ylabel('Temperatura (°C)',  fontsize = 10)
plt.xlabel('Horas',  fontsize = 10)

plt.plot(DadosMet['temperatura'][:24], color='red')
plt.show()

#@title **Gráfico chuva mês 1 do primeiro ano**
plt.figure(figsize=(10,4))

plt.grid(True)
plt.title(f'Chuva - {anos[0]}-01',  fontsize = 10)
plt.ylabel('Chuva (mm)',  fontsize = 10)
plt.xlabel('Horas',  fontsize = 10)

plt.plot(DadosMet['chuva'][:24*30], color='blue')
plt.show()

#@title **Simulação de Sujidade com Modelo de Kimber**

# Parâmetros do modelo de Kimber para o clima de Vitória
soiling_loss_rate = 0.0020
cleaning_threshold = 25
grace_period = 14
max_soiling = 0.3

# O modelo `pvlib.soiling.kimber` retorna o "soiling ratio", um fator entre 0 e 1 [3]
soiling_ratio_series = kimber(
    rainfall=DadosMet['chuva'],
    cleaning_threshold=cleaning_threshold,
    soiling_loss_rate=soiling_loss_rate,
    grace_period=grace_period,
    max_soiling=max_soiling
)

soiling_ratio_series.name = 'soiling'

# Isso garante que a série soiling_ratio_series tenha exatamente o mesmo índice (datas e horários) que o DataFrame DadosMet.
soiling_ratio_series = soiling_ratio_series.reindex(DadosMet.index)

# O `soiling_ratio_series` será uma série temporal com o mesmo índice que `DadosMet`, mas com valores diários
soiling_ratio_series = soiling_ratio_series.interpolate(method='time').ffill().bfill()


plt.figure(figsize=(8,4))

# daily rain totals
daily_rain = DadosMet['chuva'].iloc[:]
plt.plot(daily_rain.index, daily_rain.values/25.4, color='blue')
plt.plot(soiling_ratio_series.index, soiling_ratio_series.values*100.0, color='maroon')
plt.hlines(
    cleaning_threshold/25.4, xmin=datetime(2016, 1, 1), xmax=datetime(2017, 12, 31),
    linestyles='--')

plt.grid()
plt.title(
    f'Modelo de Sujidade de Kimber, a linha tracejada mostra o limite ({cleaning_threshold}[mm])')
plt.xlabel('tempo')
plt.ylabel('Acúmulo de sujeira e precipitação diária')
plt.legend(['precipitação diária [polegadas]', 'sujeira [%]'])
plt.tight_layout()

plt.xlim(pd.Timestamp('2016-01-01 00:00:00'), pd.Timestamp('2017-12-31 23:00:00'))

plt.show()

#@title **Informações da placa**
# https://www.neosolar.com.br/loja/painel-solar-fotovoltaico-280w-osda-oda280-30-p.html

#POTENCIA GERADA PELOS PV's DO MODELO ODA280-30-P 280W
Vmppt = 31.94   # é a tensão no ponto de máxima potência (V);
Imppt = 8.77    # é a corrente no ponto de máxima potência (A).
Voc = 38.33     # é a tensão de circuito aberto do módulo (V);
Isc = 9.41      # é a corrente de curto circuito da célula (A);
nc = 0.1899     # é a eficiência da placa
Not = 45        # é a temperatura nominal de operação da célula (oC);
Kv = -0.3       # é o coeficiente de tensão/temperatura (V/ oC);
Ki = 0.06       # é o coeficiente de corrente/temperatura (A/ oC);

# Constantes
RNOCT = 1000
ta = 0.9

power_placa = Voc*Isc   # é a potencia da Placa

NPaineis = {}
ir_med = 4.5
horas_exposto = 6       # é a quantidade de horas de exposição da placa
for user in users:
    consumo_medio = (consumidor[user]*1000).mean().iloc[0] # media Wh
    NPaineis[user] =  math.ceil((consumo_medio/(power_placa*ir_med*0.75*horas_exposto)))
print(f"Placas - {NPaineis}")

#@title **Painel solar**
base_power = []
for idx, row in DadosMet.iterrows():
    r   = row['irradiancia']
    Ta  = row['temperatura']
    Vw  = row['vento']
    Tc  = Ta + ((r/RNOCT) * (9.5/(5.7+3.8*Vw)) * (Not-20) * (1 - (nc/ta)))
    I   = r * (Isc + Ki *(Tc-25))
    V   = Voc - Kv *(Tc-25)
    FF  = (Vmppt * Imppt)/(Voc * Isc)
    base_power.append((idx, FF * V * I / 10000))

def PowerPainel(users=users, DadosMet=DadosMet):
    PotPVM, PotPVMS = {}, {}
    for user in users:
        PotPVM[user], PotPVMS[user] = [], []
        for idx, power in base_power:
            power       *= NPaineis[user]
            power_suj   = power * (1 - soiling_ratio_series.loc[idx])

            PotPVM[user].append(power)
            PotPVMS[user].append(power_suj)

        PotPVM[user]  = pd.DataFrame(PotPVM[user], index=DadosMet.index, columns=["Power (kW)"])
        PotPVMS[user] = pd.DataFrame(PotPVMS[user], index=DadosMet.index, columns=["Power (kW)"])
    return PotPVM, PotPVMS

def PowerPainel_optimizado(dates_limpeza):
    # Converte as datas de limpeza de string para datetime.date
    clean_dates = [datetime.strptime(d, '%Y-%m-%d').date() for d in dates_limpeza]
    
    soiling_ratio_series_optimized = kimber(
        rainfall=DadosMet['chuva'],
        cleaning_threshold=cleaning_threshold,
        soiling_loss_rate=soiling_loss_rate,
        grace_period=grace_period,
        max_soiling=max_soiling,
        manual_wash_dates=clean_dates
    )
    soiling_ratio_series_optimized = soiling_ratio_series_optimized.reindex(DadosMet.index)
    soiling_ratio_series_optimized = soiling_ratio_series_optimized.interpolate(method='time').ffill().bfill()
    
    PotPVMS_optimizado = {}
    for user in users:
        PotPVMS_optimizado[user] = []
        for idx, power in base_power:
            power *= NPaineis[user]
            power_suj_optimizado = power * (1 - soiling_ratio_series_optimized.loc[idx])
            PotPVMS_optimizado[user].append(power_suj_optimizado)
        PotPVMS_optimizado[user] = pd.DataFrame(PotPVMS_optimizado[user], index=DadosMet.index, columns=["Power (kW)"])
    return PotPVMS_optimizado

PotPVM, PotPVMS = PowerPainel()
PotPVM[users[0]].iloc[:24,:]

PotPVM[user].iloc[:24,:].index.strftime('%HH')

#@title **Geração no dia 1 do primeiro ano**
plt.figure(figsize=(8,4))

for user in users[:10]:
    plt.plot(PotPVM[user].iloc[:,:].index, PotPVM[user].values)

label_figure(users, 'Geração Painel solar', 'Potência (kW)', 'Horas', 16, 0)

plt.ylim(0, 65)
plt.xlim(pd.Timestamp('2016-06-22 00:00:00'), pd.Timestamp('2016-06-22 23:00:00'))

os.makedirs("./figuras/geracao", exist_ok=True)
plt.savefig(f"./figuras/geracao/{max_users}-geracao.eps", format='eps')
plt.show()

#@title **Geração com sujidade**
plt.figure(figsize=(8,4))

# Soma mensal direto para todos os usuários
pvm  = pd.concat([PotPVM[u]  for u in users], axis=1).resample("ME").sum().sum(axis=1)
pvms = pd.concat([PotPVMS[u] for u in users], axis=1).resample("ME").sum().sum(axis=1)

plt.plot(pvm.index, pvm.values, label="Geração sem sujidade")   # type: ignore
plt.plot(pvms.index, pvms.values, label="Geração com sujidade") # type: ignore

label_figure(['Geração sem sujidade', 'Geração com sujidade'], 'Geração Painel solar com sujidade', 'Potência (kW)', 'Meses', 16, 0)

os.makedirs("./figuras/geracao", exist_ok=True)
plt.savefig(f"./figuras/geracao/{max_users}-geracao-sujidade.eps", format='eps')
plt.show()

total = sum([(PotPVM[user].sum() - PotPVMS[user].sum()).values[0] for user in users])
porcentagem = (total / sum([PotPVM[user].sum().values[0] for user in users])) * 100
print(f"Potencia perdida por sujidade: {total/1000:.2f} MW")
print(f"Porcentagem perdida por sujidade: {porcentagem:.2f}%")

#@title **EnergBaterry**
def energBaterry(l, g, max_battery):
  battery = 0
  bat   = l.copy()*0
  load  = l.copy()
  grid  = g.copy()


  for i, energ in enumerate(zip(load.iloc[:,0], grid.iloc[:,0])):
    geracao, consumo = energ
    if int(bat.iloc[i:i+1,:].index[0].strftime('%H')) == 1:
      battery = 0
    elif(i):
      battery    = bat.iloc[i-1,0]

    res   = geracao - consumo

    if(res < 0):
      consumo = (-1) * res
      res = 0
      consumo = consumo - battery
      if(consumo < 0):
        battery = (-1) * consumo
        consumo = 0
      else:
        battery = 0
    elif (battery < max_battery):
      consumo = 0
      if (res <= (max_battery-battery)):
        battery = battery + res
        res     = 0
      else:
        res     = res - (max_battery - battery)
        battery = max_battery
    else:
      consumo = 0

    grid.iloc[i,0]  = consumo
    load.iloc[i,0]  = res
    bat.iloc[i,0]   = battery

  df = round(pd.concat([grid, load, bat], axis=1), 1) # type: ignore
  df.columns = ['grid', 'load', 'battery']
  return df

print(f"geração len - {len(PotPVM[users[0]])}, consumo len - {len(consumidor[users[0]])}")

# Bateria Megapack Tesla 1.9MW
max_battery = 1900 # kW
qtd_battery = 0

consumidor_baterry = {}
for chave, consumo in consumidor.items():
    consumidor_baterry[chave] = energBaterry(PotPVM[chave], consumo, max_battery * qtd_battery)
consumidor_baterry[users[0]].iloc[:24,:]

## Se valores ficarem None, datas diferentes entre geração e consumo
sum([consumidor_baterry[user].isna().sum().sum() for user in users])

for user in users[:10]:
    plt.figure(figsize=(8,4))
    plt.grid(True)
    plt.title(user+f'- Consumo {anos[0]} à {anos[1]}',  fontsize = 10)
    plt.ylabel('kW',  fontsize = 10)
    plt.xlabel('Mês',  fontsize = 10)

    plt.plot(consumidor_baterry[user].resample('ME').sum().resample('ME').mean())
    plt.legend(['Grid', 'Load', 'battery'])
    plt.show()

#@title **Carga e descarga da bateria nos primeiros 4 mês de Janeiro de 2017 - Danna**
plt.figure(figsize=(12,4))

plt.grid(True)
plt.title(f'Carga e descarga da bateria de {anos[0]} à {anos[1]} - '+users[0],  fontsize = 10)
plt.ylabel('carga (kW)',  fontsize = 10)
plt.xlabel('Data',  fontsize = 10)

plt.plot(consumidor_baterry[users[0]]['battery'])#.iloc[:24*30*4,2:3])

plt.show()

consumo_ano = {}
for user in users:
    consumo_ano[user] = consumidor_baterry[user].resample('ME').sum()
    # consumo_ano[user] = consumidor_baterry[user].copy()
display(consumo_ano[users[0]])

# Criar um dicionário vazio para armazenar os DataFrames de crédito
credit = {user: pd.DataFrame(0.0, index=df.index, columns=['grid', 'load']) for user, df in consumo_ano.items()}

# Remover
for user in users:
    credit[user] = consumo_ano[user]#.iloc[:-3,:]
display(credit[users[0]])

tarifa_unitaria = pd.DataFrame(index=pd.date_range(start='2016-01-31 00:00:00', end='2017-12-31 23:00:00', freq='1h'))
tarifa_unitaria = tarifa_unitaria.reindex(consumidor[users[0]].index)
tarifa_unitaria['tarifa_unitaria'] = 0.0

# SUBGRUPO A4 (TUSD + TE) Modalidade Verde
tarifa_2015 = {'ponta': 0.68877 + 0.39493, 'fora ponta': 0.07451 + 0.24742} # RESOLUÇÃO HOMOLOGATÓRIA No 1.927, DE 4 DE AGOSTO DE 2015
tarifa_2016 = {'ponta': 0.51204 + 0.38631, 'fora ponta': 0.11703 + 0.24937} # RESOLUÇÃO HOMOLOGATÓRIA No 2.182, DE 29 DE NOVEMBRO DE 2016
tarifa_2017 = {'ponta': 1.24856 + 0.35173, 'fora ponta': 0.06780 + 0.22941} # RESOLUÇÃO HOMOLOGATÓRIA No 2.207, DE 14 DE MARÇO DE 2017

for idx in tarifa_unitaria.index:
    if idx.year == 2016:
        if idx.month < 11 or (idx.month == 11 and idx.day < 29):
            tarifa = tarifa_2015
        else:
            tarifa = tarifa_2016
    else:
        if idx.month < 3 or (idx.month == 3 and idx.day < 14):
            tarifa = tarifa_2016
        else:
            tarifa = tarifa_2017

    if 18 <= idx.hour <= 21:
        tarifa_unitaria.loc[idx, 'tarifa_unitaria'] = tarifa['ponta']
    else:
        tarifa_unitaria.loc[idx, 'tarifa_unitaria'] = tarifa['fora ponta']

display(tarifa_unitaria)

#@title **Tarifa no ano de 2016**
plt.figure(figsize=(8,4))

plt.grid(True)
plt.title('Tarifa no ano de 2016',  fontsize = 10)
plt.ylabel('Tarifa(R$/kWh)',  fontsize = 10)
plt.xlabel('Mês',  fontsize = 10)

plt.plot(tarifa_unitaria.iloc[:168,:])

plt.show()

#@title **Tarifas nos anos de 2016 à 2017**
plt.figure(figsize=(8,4))

plt.grid(True)
plt.title('Tarifas nos anos de 2016 à 2017',  fontsize = 10)
plt.ylabel('Tarifa(R$/kWh)',  fontsize = 10)
plt.xlabel('Mês',  fontsize = 10)

plt.plot(tarifa_unitaria['tarifa_unitaria'].resample('ME').mean())

plt.show()

# Agrupamento
agrupamento     = lambda dados: pd.concat([df for df in dados.values()], axis=1).sum(axis=1).to_frame(name=dados[users[0]].columns[0])
consumidor_ALL  = agrupamento(consumidor)
consumidor_ALL

#@title **Custo anual de eletricidade**
c_fit = 0
c_tarifa_unitaria = tarifa_unitaria.iloc[:,0]

# Nova função Ce para incluir o custo da limpeza
def Ce(e_b, dates_limpeza):
    PotPVMS_optimizado = PowerPainel_optimizado(dates_limpeza)
    return (energBaterry(agrupamento(PotPVMS_optimizado), consumidor_ALL, e_b)['grid'] * c_tarifa_unitaria).sum()

#@title **Custo anual relacionado à bateria**
SOH         = 0.8
rep         = 0.6
capacidade  = 19.3 * 10**6 # capacidade de geração anual (MWh)
custo       = 5045400 # custo bateria em Dolar
dolar       = 5.47 # cotação do dolar em 2025
c_ic        = (custo * dolar) / capacidade  # custo de instalação do BESS no brasil (R$/Wh)
e_b         = 3.9 * 10**6 # capacidade da bateria

c_bat       = lambda e_b: (((1-SOH)/(1-rep))*c_ic*e_b)

round(c_bat(e_b),2)

#@title **Custo anual total do sistema solar com bateria**
Cop = lambda e_b: c_bat(e_b) + Ce(e_b, []) # AQUI TEM QUE SER AJUSTADO PARA OTIMIZAÇÃO

C_pv = lambda indicador=1: (energBaterry(agrupamento(PowerPainel()[indicador]), consumidor_ALL, 0)['grid'] * c_tarifa_unitaria).clip(lower=0).sum()
C_pv()

C_pv(0), C_pv(1)

#@title **C_sav**
C_sav = lambda e_b: C_pv() - Cop(e_b)
round(C_sav(2000), 2)

#@title **Retorno de investimento**
roi = lambda e_b: (C_sav(e_b)/c_bat(e_b))*100
round(roi(348528.36539327),2)

PotPVMS_cache = agrupamento(PowerPainel()[1])
def Ce_cached(e_b):
    return sum(energBaterry(PotPVMS_cache, consumidor_ALL, e_b)['grid'] * c_tarifa_unitaria.values)


# Definir o problema de otimização
# n_var = 1 para e_b e n_dates para as datas
n_dates = 12  # Número de limpezas a serem otimizadas
n_var = 1 + n_dates # e_b + datas de limpeza
max_baterry = 3.9*10**6
max_dias = 365*2 # 2 anos de dados

def cost_limpeza(dates_limpeza):
    custo_por_painel = 20  # Custo por painel em R$
    return custo_por_painel * sum(NPaineis[user] for user in users) * len(dates_limpeza)

def objective_function(x):
    e_b = x[0]
    # As variáveis de otimização para as datas de limpeza são os dias do ano
    dates_limpeza_int = np.sort(np.unique(np.round(x[1:]).astype(int)))
    dates_limpeza = [(pd.Timestamp('2016-01-01') + pd.Timedelta(days=int(d))).strftime('%Y-%m-%d') for d in dates_limpeza_int]

    custo_bat = c_bat(e_b)
    custo_eletricidade = Ce(e_b, dates_limpeza)
    custo_limpeza = cost_limpeza(dates_limpeza)
    
    return [custo_bat, custo_eletricidade, custo_limpeza]

objs = [
    lambda x: objective_function(x)[0], # Custo da bateria
    lambda x: objective_function(x)[1], # Custo da eletricidade
    lambda x: objective_function(x)[2]  # Custo da limpeza
]

problem = FunctionalProblem(n_var, objs, xl=np.zeros(n_var), xu=np.array([max_baterry] + [max_dias]*n_dates))

# Configurar o algoritmo NSGA-III
num_ref_dirs = 100
ref_dirs_custom = get_reference_directions("das-dennis", 3, n_points=num_ref_dirs)
algorithm = NSGA3(pop_size=num_ref_dirs, ref_dirs=ref_dirs_custom)

# Executar a otimização
result = minimize(problem, algorithm, seed=980, termination=('n_gen', 50), verbose=True)

final_population = result.X
final_objectives = result.F

# Imprimir os resultados
lista = []
for individual, objectives in zip(final_population, final_objectives):
    dist = np.linalg.norm([0, 0, 0] - objectives)
    print("Individual: ", individual)
    print("Objectives: ", objectives)
    print("Distancia:  ", [dist])
    print("------------------------")

    lista.append((individual, objectives, dist))

print(min(lista, key=lambda x: x[2]))

scatter_plot = Scatter(figsize=(8,6), d_s=20).add(result.F, s=20).show()
scatter_plot.save("scatter_plot.png")

custo_por_painel        = 20  # Custo por painel em R$
custo_limpeza_sistema   = custo_por_painel * sum(NPaineis[user] for user in users) # Custo total de limpeza do sistema
custo_limpeza_sistema

# Criação do gráfico
plt.figure(figsize=(8, 6))

# Plotar cada objetivo em uma reta
plt.plot(final_objectives[:, 0], label="C_bat")
plt.plot(final_objectives[:, 1], label="Ce")
plt.plot(final_objectives[:, 2], label="C_limpeza")

# Encontrar o ponto mínimo na lista de tuplas (individual, objectives, dist)
min_dist_point = min(lista, key=lambda x: x[2])

# Extrair o índice do ponto mínimo na lista
min_dist_index = lista.index(min_dist_point)

# Marcando o ponto mínimo no gráfico
plt.scatter(min_dist_index, min_dist_point[1][0], color='red', label='Ponto Mínimo (C_bat)')
plt.scatter(min_dist_index, min_dist_point[1][1], color='red')
plt.scatter(min_dist_index, min_dist_point[1][2], color='red')

plt.xlabel("População")
plt.ylabel("Valor dos Objetivos")
plt.legend()
plt.grid(True)
plt.title("Comparativo do custo em cada geração")
plt.show()

import matplotlib.pyplot as plt

# Rótulos dos objetivos
labels = ['C_bat', 'Ce', 'C_limpeza']

# Criar o boxplot
plt.boxplot(final_objectives, labels=labels)

# Configurar o gráfico
plt.title('Boxplot dos Objetivos')
plt.xlabel('Objetivos')
plt.ylabel('Valores')
plt.grid(True)

# Exibir o gráfico
plt.show()

# Função para verificar se um ponto é dominado por outro ponto
def is_dominated(point, other_points):
    return np.any(np.all(point >= other_points, axis=1))

# Encontrar o conjunto de Pareto
pareto_front = []
for i, point in enumerate(final_objectives):
    if not is_dominated(point, np.delete(final_objectives, i, axis=0)):
        pareto_front.append(point)

pareto_front = np.array(pareto_front)

# Encontrar o ponto mínimo na lista de tuplas (individual, objectives, dist)
min_dist_point = min(lista, key=lambda x: x[2])

# Extrair o índice do ponto mínimo na lista
min_dist_index = lista.index(min_dist_point)

# Plotar o gráfico de dispersão 3D
fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')

ax.scatter(final_objectives[:, 0], final_objectives[:, 1], final_objectives[:, 2], label="Outros Pontos")
ax.scatter(final_objectives[min_dist_index, 0], final_objectives[min_dist_index, 1], final_objectives[min_dist_index, 2], color='red', label="Ponto Mínimo")

# Definir os rótulos dos eixos
ax.set_xlabel("C_bat")
ax.set_ylabel("Ce")
ax.set_zlabel("C_limpeza")

# Definir o título do gráfico
ax.set_title("Conjunto de Pareto 3D")

# Exibir a legenda
ax.legend()

# Exibir o gráfico
plt.show()

b = min(lista, key=lambda x: x[2])[0][0]
dates_optimised_int = np.sort(np.unique(np.round(min(lista, key=lambda x: x[2])[0][1:]).astype(int)))
dates_optimised = [(pd.Timestamp('2016-01-01') + pd.Timedelta(days=int(d))).strftime('%Y-%m-%d') for d in dates_optimised_int]

print(f"O tamanho ideal da bateria (C_bat) é: {round(b, 2)} Wh")
print(f"O número de limpezas ideal é: {len(dates_optimised)}")
print(f"As datas de limpeza ideais são: {dates_optimised}")
print(f"O custo anual de eletricidade (Ce) é: {round(Ce(b, dates_optimised), 2)} R$")
print(f"O custo anual da bateria (C_bat) é: {round(c_bat(b), 2)} R$")
print(f"O custo total de limpeza (C_limpeza) é: {round(cost_limpeza(dates_optimised), 2)} R$")
